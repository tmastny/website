---
title: MRP Using brms and tidybayes
author: ~
date: '2017-11-20'
slug: multilevel-mrp-tidybayes-brms-stan
categories: []
tags: []
description: Multilevel Regression and Poststratification with Stan
meta_img: /images/image.jpg
output:
  blogdown::html_page:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, 
                      results='show', cache=TRUE, autodep=TRUE)
```


## Introduction

In the last post I wrote the ["MRP Primer" Primer](https://timmastny.netlify.com/blog/poststratification-with-dplyr/) studying the *p* part of MRP: poststratification. This post explores the actual [MRP Primer by Jonathan Kastellec](http://www.princeton.edu/~jkastell/mrp_primer.html). Jonathan and his coauthors wrote this excellent tutorial on Multilevel Regression and Poststratification (MRP) using `r-base` and `arm`/`lme4`.

The aim of the MRP Primer is to estimate state level opinions for gay marriage based on a potentially non-representative survey data. That requires poststratification. As was done in the last post, we are going to use external Census data to scale the average support of each demographic group in proportion to its percentage of the state population.

Previously, we used empirical means to find the average demographic group support. Here, we'll use multilevel regression which has [well documented advantages](http://andrewgelman.com/2014/01/21/everything-need-know-bayesian-statistics-learned-eight-schools/) to compared to empirical means and traditional regression models. These multilevel models allow us to partially pool information across similar groups, providing better estimates for groups with sparse (or even non-existent) data. 

Inspired by Austin Rochford's full Bayesian implementation of the MRP Primer using [PyMC3](https://gist.github.com/AustinRochford/bfc20cb3262169b41b730bd9faf74477), I decided to approach the problem using R and [Stan](http://mc-stan.org/). In particular, I wanted to highlight two packages:

- [`brms`](https://github.com/paul-buerkner/brms), which provides a `lme4` like interface to Stan. And

- [`tidybayes`](https://github.com/mjskay/tidybayes), which is a general tool for tidying Bayesian package outputs.

Additionally, I'd like to do a three-way comparison between the empirical mean disaggregated model, the maximum likelihood estimated multilevel model, the full Bayesian model. This includes some graphical map comparisons with the `albersusa` package.

Here's what we'll need to get started

```{r}
library(tidyverse)
library(lme4)
library(brms)
library(rstan)
library(albersusa)
library(cowplot)
library(forcats)

rstan_options(auto_write=TRUE)
options(mc.cores=parallel::detectCores())
```

## The Data

Here are the three data sets we'll need. First the `marriage.data` is a compilation of gay marriage polls that we hope can give us a perspective on the support of gay marriage state by state. `Statelevel` provides some additional state information we'll use as predictors in our model, such as the proportion of religious voters. And just like [last time](https://timmastny.netlify.com/blog/poststratification-with-dplyr/), the Census data will provide our poststratification weights. 

```{r}
marriage.data <- foreign::read.dta('gay_marriage_megapoll.dta',
                                   convert.underscore=TRUE)
Statelevel <- foreign::read.dta("state_level_update.dta",
                                convert.underscore = TRUE)
Census <- foreign::read.dta("poststratification 2000.dta",
                            convert.underscore = TRUE)
```

### Tidying Variables

The MRP Primer takes a very literal, `r-base` approach to recoding the demographic variables and combining data across data frames. Here, I try to [tidy](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) the data, based on the philosophy and tools of the `tidyverse` collection of packages. Personally, I think cleaning the data in this manner is simpler and more descriptive of the tidying goals. 

```{r}
# add state level predictors to marriage.data
Statelevel <- Statelevel %>% rename(state = sstate)

marriage.data <- Statelevel %>%
  select(state, p.evang, p.mormon, kerry.04) %>%
  right_join(marriage.data)

# Combine demographic groups
marriage.data <- marriage.data %>%
  mutate(race.female = (female * 3) + race.wbh) %>%
  mutate(age.edu.cat = 4 * (age.cat - 1) + edu.cat) %>%
  mutate(p.relig = p.evang + p.mormon)
```

### Tidying Poststratification

Now that the data is broken down into the demographic groups, the next step is to find the percentage of the total state population for each group so we can poststratify. We want to code the Census demographics in the same way as in the gay marriage polls so we can 

```{r}
# change column names for natural join with marriage.data
Census <- Census %>% 
  rename(state = cstate,
         age.cat = cage.cat,
         edu.cat = cedu.cat,
         region = cregion)

Census <- Statelevel %>%
  select(state, p.evang, p.mormon, kerry.04) %>%
  right_join(Census)

Census <- Census %>%
  mutate(race.female = (cfemale * 3 ) + crace.WBH) %>%
  mutate(age.edu.cat = 4 * (age.cat - 1) + edu.cat) %>%
  mutate(p.relig = p.evang + p.mormon)
```

Then we can just include the Census rates as a column in the gay marriage poll data.

```{r}
# marriage.data <- Census %>%
#   select(state, kerry.04, race.female, age.edu.cat)
```


## Model 1: Disaggragation

The first model we'll build is the disaggregate model. This model simply calculates the averages in each state by taking the mean of responses within each state. 

```{r}
mod.disag <- marriage.data %>%
  group_by(state) %>%
  summarise(support = mean(yes.of.all)) %>%
  mutate(model = "no_ps")
```

This simplicity comes at a cost. As demonstrated in the previous post, the empirical mean is not representative of the actual state mean if the respondents within are not in proportion to each group's percentage of the total population. So let's build the poststratified disaggregated model.

First we'll find the average of within each group:

```{r}
grp.means <- marriage.data %>%
  group_by(state, region, race.female, age.cat, 
           edu.cat, age.edu.cat, p.relig, kerry.04) %>%
  summarise(support = mean(yes.of.all, na.rm=TRUE))
```

Then we'll add in the group's percentage in each state:

```{r}
grp.means <- Census %>%
  select(state, age.cat, edu.cat, region, kerry.04,
         race.female, age.edu.cat, p.relig, cpercent.state) %>%
  right_join(grp.means)
```

Then we'll sum the scaled group averages and get the total state averages:

```{r}
mod.disag.ps <- grp.means %>%
  group_by(state) %>%
  summarise(support = sum(support * cpercent.state, na.rm=TRUE)) %>%
  mutate(model = "ps")
```

Here's the difference:

```{r}
disag.point <- bind_rows(mod.disag, mod.disag.ps) %>%
  group_by(model) %>%
  arrange(support, .by_group=TRUE) %>%
  filter(state != "") %>%
  ggplot(aes(x = support, y=forcats::fct_inorder(state), color=model)) + 
  geom_point() + 
  theme_classic() + theme(legend.position = 'none') +  
  directlabels::geom_dl(aes(label=model), method='smart.grid') +
  ylab('state')

disag.scat <- bind_cols(mod.disag, mod.disag.ps) %>%
  filter(state != "") %>%
  ggplot(aes(x = support, y=support1)) + 
  geom_text(aes(label=state), hjust=0.5, vjust=0.25) +
  geom_abline(slope = 1, intercept = 0) +
  xlim(c(0,0.7)) + ylim(c(0,0.7)) + 
  xlab("support") + ylab("poststrat support") +
  coord_fixed()

plot_grid(disag.point, disag.scat)
```

*** try ggcow subset within subject plot

And here's the problem:

```{r, out.height='300px'}
grp.means %>%
  group_by(state) %>%
  summarise(total_percent = sum(cpercent.state, na.rm=TRUE)) %>%
  filter(state != "") %>%
  ggplot(aes(x = state, y = total_percent)) +
  geom_point() +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + 
  coord_fixed(ratio=8)
```


The lack of data for some voter groups makes poststratifying on the state level impossible and/or meaningless. This scenario actually motivates multilevel regression. As we'll see in the next section, the multilevel model assumes similar demographic groups tend to vote the same. For example, suppose no black women were polled in South Dakota. Instead of producing skewed estimates, we can estimate the proportion of support black women have for gay marriage in South Dakota by level of support (and variation of support) black women have in all other states. 


## Model 2: Maximum Likelihood Multilevel Model

```{r}
approx.mod <- glmer(formula = yes.of.all ~ (1|race.female)
                    + (1|age.cat) + (1|edu.cat) + (1|age.edu.cat)
                    + (1|state) + (1|region) + (1|poll)
                    + p.relig + kerry.04,
                    data=marriage.data, family=binomial(link="logit"))
```
```{r}
summary(approx.mod)
```

First, note that I didn't include the standard error from the MLE method. In general, this is [hard to do](https://stackoverflow.com/questions/31694812/standard-error-of-variance-component-from-the-output-of-lmer), but we get the percentile intervals for free with using `brms`. 

## Model 3: Full Bayesian Model

```{r, results='hide'}
bayes.mod <- brm(yes.of.all ~ (1|race.female) + (1|age.cat) + (1|edu.cat)
                 + (1|age.edu.cat) + (1|state) + (1|region) + (1|poll)
                 + p.relig + kerry.04,
                 data=marriage.data, family=bernoulli(),
                 prior=c(set_prior("normal(0,0.2)", class='b'),
                         set_prior("normal(0,0.2)", class='sd', group="race.female"),
                         set_prior("normal(0,0.2)", class='sd', group="age.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="age.edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="state"),
                         set_prior("normal(0,0.2)", class='sd', group="region"),
                         set_prior("normal(0,0.2)", class='sd', group="poll")))
```
```{r}
summary(bayes.mod)
```




## Model Comparisons


One comparison I like is what Matt Vuorre calls [with-subject scatterplots](https://mvuorre.github.io/post/2017/within-subject-scatter/). Although we are using them for a difference purpose here, the basic idea is really neat. Austin Rochford also uses a similar chart, but instead of dots I am going to plot the [two letter](http://andrewgelman.com/2009/01/14/state-by-state/) [state abbreviation](http://andrewgelman.com/2014/05/16/gullibility-effect-using-state-level-correlations-draw-pretty-much-conclusion-want-individual-level-causation/). 






