---
title: MRP Using brms and tidybayes
author: ~
date: '2017-11-20'
slug: multilevel-mrp-tidybayes-brms-stan
categories: []
tags: []
description: Multilevel Regression and Poststratification with Stan
meta_img: /images/image.jpg
draft: true
output:
  blogdown::html_page:
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE, 
                      results='show', cache=TRUE, autodep=TRUE)
```


## Introduction

In the last post I wrote the ["MRP Primer" Primer](https://timmastny.netlify.com/blog/poststratification-with-dplyr/) studying the *p* part of MRP: poststratification. This post explores the actual [MRP Primer by Jonathan Kastellec](http://www.princeton.edu/~jkastell/mrp_primer.html). Jonathan and his coauthors wrote this excellent tutorial on Multilevel Regression and Poststratification (MRP) using `r-base` and `arm`/`lme4`.

Inspired by Austin Rochford's full Bayesian implementation of the MRP Primer using [PyMC3](https://gist.github.com/AustinRochford/bfc20cb3262169b41b730bd9faf74477), I decided to approach the problem using R and [Stan](http://mc-stan.org/). In particular, I wanted to highlight two packages:

- [`brms`](https://github.com/paul-buerkner/brms), which provides a `lme4` like interface to Stan. And

- [`tidybayes`](https://github.com/mjskay/tidybayes), which is a general tool for tidying Bayesian package outputs.

Additionally, I'd like to compare the empirical mean disaggragated model, the maximum likelihood estimated multilevel model, the full Bayesian model. 

Lastly, I'll be doing some graphical map comparisons with the `albersusa` package.

Here's what we'll need to get started

```{r}
library(tidyverse)
library(lme4)
library(brms)
library(rstan)
library(albersusa)

rstan_options(auto_write=TRUE)
options(mc.cores=parallel::detectCores())
```

## The Data

Here are the three data sets we'll need. First the `marriage.data` is a compliation of gay marriage polls that we hope can give us a perspective on the support of gay marriage state by state. `Statelevel` provides some additional state information we'll use as predictors in our model, such as the proportion of religious voters. And just like [last time](https://timmastny.netlify.com/blog/poststratification-with-dplyr/), the Census data will provide our poststratification weights. 

```{r}
marriage.data <- foreign::read.dta('gay_marriage_megapoll.dta',
                                   convert.underscore=TRUE)
Statelevel <- foreign::read.dta("state_level_update.dta",
                                convert.underscore = TRUE)
Census <- foreign::read.dta("poststratification 2000.dta",
                            convert.underscore = TRUE)
```

### Tidying data

Here, I am proceeding just as Jonathan Kastellec. We want to code our demographic groups in a consistent way across our data so we can easily poststratify.

```{r}
Statelevel <- Statelevel %>% arrange(sstate.initnum)
Census <- Census %>% arrange(cstate)
```

This section is copied straight from the MRP Primer. I'm not aware of a tidy way to handle this numerical coding of demographics. Let me know in the comments if you have some suggestions. 

We'll be joining the data based on the state number.
```{r}
# add state level predictors to marriage.data
Statelevel <- Statelevel %>% rename(state.initnum = sstate.initnum)

marriage.data <- Statelevel %>%
  select(state.initnum, p.evang, p.mormon, kerry.04) %>%
  right_join(marriage.data)

# Combine demographic groups
marriage.data <- marriage.data %>%
  mutate(race.female = (female * 3) + race.wbh) %>%
  mutate(age.edu.cat = (female * 3) + race.wbh) %>%
  mutate(p.relig = p.evang + p.mormon)

# add predictors
# Census$cstate.initnum <-  match(Census$cstate, Statelevel$sstate)
# 
# Census$crace.female <- (Census$cfemale * 3) + Census$crace.WBH
# Census$cage.edu.cat <- 4 * (Census$cage.cat - 1) + Census$cedu.cat
# Census$cp.relig.full <- Census$cp.evang.full + Census$cp.mormon.full
# 
# Census$cp.evang.full<-  Statelevel$p.evang[Census$cstate.initnum]
# Census$cp.mormon.full <- Statelevel$p.mormon[Census$cstate.initnum]
# 
# Census$cp.kerry.full <-  Statelevel$kerry.04[Census$cstate.initnum]
```


## Model 1: Disaggragation

```{r}
marriage.opinion <- marriage.data %>%
  group_by(statename) %>%
  summarise(support = mean(yes.of.all))
marriage.opinion
```

As an aside, I really dislike this coding scheme as it seems to make the interpretation of the categorical quantities very difficult to understand. I'd like to try an alternative reformulation of the indicators later, or have a function to convert them a la `tidybayes` to easily understand. 

Next, we code the system census in the same way.

## Model 2: Maximum Likelihood Multilevel Model

```{r}
approx.mod <- glmer(formula = yes.of.all ~ (1|race.female) 
                    + (1|age.cat) + (1|edu.cat) + (1|age.edu.cat) 
                    + (1|state) + (1|region) + (1|poll) 
                    + p.relig + kerry.04,
                          data=marriage.data, family=binomial(link="logit"))
```
```{r}
summary(approx.mod)
```

First, note that I didn't include the standard error from the MLE method. In general, this is [hard to do](https://stackoverflow.com/questions/31694812/standard-error-of-variance-component-from-the-output-of-lmer), but we get the percentile intervals for free with using `brms`. 

## Model 3: Full Bayesian Model

```{r, results='hide'}
bayes.mod <- brm(yes.of.all ~ (1|race.female) + (1|age.cat) + (1|edu.cat)
                 + (1|age.edu.cat) + (1|state) + (1|region) + (1|poll)
                 + p.relig + kerry.04,
                 data=marriage.data, family=bernoulli(),
                 prior=c(set_prior("normal(0,0.2)", class='b'),
                         set_prior("normal(0,0.2)", class='sd', group="race.female"),
                         set_prior("normal(0,0.2)", class='sd', group="age.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="age.edu.cat"),
                         set_prior("normal(0,0.2)", class='sd', group="state"),
                         set_prior("normal(0,0.2)", class='sd', group="region"),
                         set_prior("normal(0,0.2)", class='sd', group="poll")))
```




## Model Comparisons


One comparison I like is what Matt Vuorre calls [with-subject scatterplots](https://mvuorre.github.io/post/2017/within-subject-scatter/). Although we are using them for a difference purpose here, the basic idea is really neat. Austin Rochford also uses a similar chart, but instead of dots I am going to plot the [two letter](http://andrewgelman.com/2009/01/14/state-by-state/) [state abbreviation](http://andrewgelman.com/2014/05/16/gullibility-effect-using-state-level-correlations-draw-pretty-much-conclusion-want-individual-level-causation/). 






