---
title: MRP Using Stan, brms, and tidybayes
author: ~
date: '2017-11-20'
slug: multilevel-mrp-tidybayes-brms-stan
categories: []
tags: []
description: Multilevel Regression and Poststratification with Stan
meta_img: /images/image.jpg
---



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Jonathan Kastellec has an excellent tutorial <a href="http://www.princeton.edu/~jkastell/mrp_primer.html">at his website</a> using Multilevel Regression and Poststratification (MRP) using <code>r-base</code> tools and the <code>arm</code> package. I’d like to explore Jonathan’s example using some new tools. First, I’d like to explore the limitations of his approximate multilevel model with <code>glmer</code>, comparing it to a <code>Stan</code> model, which explores the whole posterior using the <code>brms</code> package.</p>
<p>Next, I want to compare the poststratified bayesian model to the disaggragated model.</p>
<p>Second, I’d like to tidy the workflow, especially using model tidying tools such as <code>broom</code> and <a href="https://github.com/mjskay/tidybayes"><code>tidybayes</code></a>.</p>
<p>Lastly, I want to work through some <code>R</code> mapping examples, using <code>albersusa</code> to visualize some of the results.</p>
<p>Austin Rochford has a similar treatment using <a href="https://gist.github.com/AustinRochford/bfc20cb3262169b41b730bd9faf74477">PyMC3</a> that I recommend you check out for an alternative perspective.</p>
</div>
<div id="disaggragation" class="section level2">
<h2>Disaggragation</h2>
<p>If our goal is to estimate state-level opinion, a simple way is to combine results from many different surveys and calculate the observed mean.</p>
<pre class="r"><code>library(tidyverse)
library(lme4)
library(brms)
library(rstan)
library(httr)

rstan_options(auto_write=TRUE)
options(mc.cores=parallel::detectCores())</code></pre>
</div>
<div id="the-data" class="section level2">
<h2>The Data</h2>
<pre class="r"><code># marriage.data &lt;- foreign::read.dta(&#39;gay_marriage_megapoll.dta&#39;,
#                                    convert.underscore=TRUE)
# Statelevel &lt;- foreign::read.dta(&quot;state_level_update.dta&quot;,
#                                 convert.underscore = TRUE)
# Census &lt;- foreign::read.dta(&quot;poststratification 2000.dta&quot;,
#                             convert.underscore = TRUE)</code></pre>
<pre class="r"><code># Statelevel &lt;- Statelevel[order(Statelevel$sstate.initnum),]
# Census &lt;- Census[order(Census$cstate),]
# Census$cstate.initnum &lt;-  match(Census$cstate, Statelevel$sstate)</code></pre>
<p>The first issue here is that survey respondants may not be in proportion to the actual population in the state. We can try to correct this with poststratification.</p>
<p>Second, the variance of undersampled groups is too large for an unbiased (observed) estimated mean to be useful. We can alleivate this by partial pooling used in multilevel regression.</p>
<p>Kastellec does a lot of variable recoding and in some ways I’m not sure the tidy way is much better, but we’ll try:</p>
</div>
<div id="model-1-disaggragation" class="section level2">
<h2>Model 1: Disaggragation</h2>
<pre class="r"><code># marriage.opinion &lt;- marriage.data %&gt;%
#   group_by(statename) %&gt;%
#   summarise(support = mean(yes.of.all))
# marriage.opinion</code></pre>
<p>As an aside, I really dislike this coding scheme as it seems to make the interpretation of the categorical quantities very difficult to understand. I’d like to try an alternative reformulation of the indicators later, or have a function to convert them a la <code>tidybayes</code> to easily understand.</p>
<p>Next, we code the system census in the same way.</p>
</div>
<div id="models" class="section level2">
<h2>Models</h2>
<pre class="r"><code># approx.mod &lt;- glmer(formula = yes.of.all ~ 
#                             (1|race.female) + (1|age.cat) +
#                             (1|edu.cat) + (1|age.edu.cat) + 
#                             (1|state) + (1|region) + (1|poll) +
#                             p.relig.full + p.kerry.full, 
#                           data=marriage.data, family=binomial(link=&quot;logit&quot;))
# 
# bayes.mod &lt;- brm(yes.of.all ~ (1|race.female) + (1|age.cat) + (1|edu.cat) 
#                  + (1|age.edu.cat) + (1|state) + (1|region) + (1|poll) 
#                  + p.relig.full + p.kerry.full, 
#                  data=marriage.data, family=bernoulli(),
#                  prior=c(set_prior(&quot;normal(0,1)&quot;, class=&#39;b&#39;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;race.female&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;age.cat&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;edu.cat&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;age.edu.cat&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;state&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;region&quot;),
#                          set_prior(&quot;normal(0,1)&quot;, class=&#39;sd&#39;, group=&quot;poll&quot;)))</code></pre>
</div>
<div id="full-bayesian" class="section level2">
<h2>Full Bayesian</h2>
<p>Let’s look at the different variance estimations for group-level effects:</p>
<p>First, note that I didn’t include the standard error from the MLE method. In general, this is <a href="https://stackoverflow.com/questions/31694812/standard-error-of-variance-component-from-the-output-of-lmer">hard to do</a>, but we get the percentile intervals for free with using <code>brms</code>.</p>
<p>For example, parameter level standard errors require a bootstrap computation or likelihood ratio test.</p>
<p>However, it isn’t clear how this effects our estimation of state-level responses. Let’s take a look at</p>
<p>One comparison I like is what Matt Vuorre calls <a href="https://mvuorre.github.io/post/2017/within-subject-scatter/">with-subject scatterplots</a>. Although we are using them for a difference purpose here, the basic idea is really neat. Austin Rochford also uses a similar chart, but instead of dots I am going to plot the convenient two letter state abbreviation.</p>
</div>
